<!DOCTYPE html>
<html>
  <head>
    <title>Clay Thomas</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>

    <div class="contents">
      <div class="header-image">
        <img src="TheNautalis.jpg" alt="The Nautalis in Vedauwoo, Wyoming"
          title="The Nautalis in Vedauwoo, Wyoming" />
      </div>

      <div class="profile-image">
        <img src="Profile.jpg" alt="Me, playing around in Rocktown, GA"
          title="Me, playing around in Rocktown, GA" />
      </div>

      <div class="page-title">
        <h1>
          <span>
            Clay Thomas
          </span>
        </h1>
      </div>
      <div class="preface">
        <p>
          I'm a PhD student in the Computer Science Theory group at Princeton
          University. I'm broadly interested in problems with interesting
          computational applications and an algebraic feel.
          I completed my undergrad in Mathematics and Computer Science at
          Purdue University, where I was fortunate to be advised
          by Elena Grigorescu.
        </p>
        <p>
          My other interests include rock climbing, gymnastics, and teaching.
        </p>
        <a href="cv.pdf">Here's my CV</a>
      </div>

      <!-- <h2>
        <span>
          News
        </span>
      </h2> -->

      <h2>
        <span>
          Publications
        </span>
      </h2>

      <cite id="mrCodesBounded"> 
        V. Gandikota, E. Grigorescu, C. Thomas, and M. Zhu.
        Maximally recoverable codes: The bounded case.
        In <em>Allerton Conference on Communication, Control, and Computing</em>, 2017.
        <a href="./papers/boundedMRC.pdf">[paper]</a>
        <a href="./talks/boundedMRCSlides.pdf">[slides]</a>
      </cite>
      <div class="abstract">
        <p>
          Modern distributed storage systems employ Maximally Recoverable codes
          that aim to balance failure recovery capabilities with
          encoding/decoding efficiency tradeoffs. Recent works of Gopalan et al
          (SODA 2017) and Kane et al (FOCS 2017) show that the alphabet size of
          grid-like topologies of practical interest must be large, a feature that
          hampers decoding efficiency.
        </p>
        <p>
          To bypass such shortcomings, in this work we initiate the study of a
          weaker version of recoverability, where instead of being able to correct
          all correctable erasure patterns (as is the case for maximal
          recoverability), we only require to correct all  erasure patterns of
          <em>bounded</em> size. The study of this notion reduces to a variant of a
          combinatorial problem studied in the literature, which is  interesting
          in its own right.
        </p>
        <p>
          We study the alphabet size of  codes withstanding  all erasure patterns
          of small (constant) size. We believe the questions we propose are
          relevant  to both real storage systems and combinatorial analysis, and
          merit further study.
        </p>
      </div>

      <h2>
        <span>
          Projects
        </span>
      </h2>

      <h3>
        Verifying Structural Invariants of Programs
      </h3>

      <p>
        <a href="./papers/structuralPerturbations.pdf">[report]</a>
        <a href="./talks/structuralPerturbationsSlides.pdf">[slides]</a>
      </p>
      <p>
        For my Reasoning About Programs course,
        I've been working on the problem of verifying structural invariants of
        programs.
        Our two key examples, and those we've had the most success with,
        are invariance under the ordering of a list
        and invariance under equivalent binary search trees.
        For both of these data types, we've found simple permutations that
        "generate" all equivalent data types,
        in the sense that applying those permutations in some order to any data
        structure can result in all structures equivalent to the input.
        We also have a more general, sound procedure that can verify the
        invariance of an arbitrary data type under some underlying
        representation (for example, a function on binary search trees should be
        invariant under the function "list" that returns the ordered list
        corresponding to the tree).
        However, our procedure includes an inductive synthesizer and an
        equivalence-of-programs verifier in its inner loop,
        so it may not be very practical.
      </p>

      <!--
      <h3>
        Trie Combinators for Searching Through ASTs
      </h3>
      -->

      <h2>
        <span>
          Teaching
        </span>
      </h2>
      <p>
        I enjoy lecturing and explaining foundational concepts.
        Furthermore, I like writing challenging and interesting practice
        questions for students (including thinking of exercises for myself!).
      </p>
      <p>
        When I TAed for Purdue's "Foundations of computer science" course,
        I wrote some lecture notes for a few of my "practice, study, observation"
        sessions and I wrote review materials for the midterm and final.
        You can find those materials
        <a href="cs182/index.html">here</a>.
      </p>

      <h3>
        Haskell
      </h3>
      <p>
        My manager at Facebook told me that there's an old saying among
        Haskellers: "The best way to learn monads is to write a monad tutorial,
        then throw it away" because nobody else will ever find it useful.
        Personally, I think monad tutorials are a myth.
        Writing a monad tutorial is like writing a "data structures" tutorial
        or a "programming patterns" tutorial: way too broad.
        Anyway, <a href="hask/listMonad.pdf">here's</a> my monad tutorial.
      </p>
      <p>
        I want make some simplified versions of Haskell libraries that are easier
        to understand so people can learn the concepts of the libraries.
        <a href="hask/lensExplanation.hs">Here's</a>
        the start of that project for the Lens library.
      </p>
      <p>
        <a href="hask/freeDecision.html">Here's</a> the "free decision trees"
        blog post (see project section below).
      </p>

      <h2>
        <span>
          Smaller Independent Projects
        </span>
      </h2>

      These are all smaller, simpler, code-based projects
      which I wrote independently.

      <h3> Ramsey Languages </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/RamseyLangs">
            January 2017.</a>
        </span>
        Haskell implementations of a simple imperative programming language
        and a simple Lisp.
        Based on operational semantics from Norman Ramsey's book Programming Languages:
        Build, Prove, Compare.
      </p>

      <h3> Fair Read-Write Locks </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/FairReadWrite">
            March 2016.</a>
        </span>
        A kernel-level read-write lock implementation in the Xinu operating system,
        giving readers and writers access in exactly the order they request it.
      </p>
      <p>
        This small project inspired a question I really want to come
        back to one day:
        Are all synchronization protocols implementable with
        common sets of synchronization primitives?
        For example, is it possible to implement fair read-write locks
        using only semaphores?
        No implementation I have seen is actually fair in the
        sense discussed above.
        See the repo for more information.
      </p>

      <h3> Free Decision Trees &mdash; Library and Blog Post </h3>
      <p>
        <span class="date">
          <a href="hask/freeDecision.html">
            January 2016.</a>
        </span>
        A rudimentary library to train and apply decision trees
        represented in an elegant way.
        This project was inspired by the observation
        that the Haskell data type
        <code>Free ((->) r) Bool</code>
        could be used to represent decision trees.
        The result is a blog-post style explanation of the concept and implementation,
        which I think is a good way to understand free monads.
        You can find the reddit discussion
        <a href="https://www.reddit.com/r/haskell/comments/455u2p/decision_trees_are_free_monads_over_the_reader/">
          here</a>.
      </p>

      <h3> Joy Interpreter </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/Joy">
            August 2015.</a>
        </span>
        A small, toy interpreter for the stack based functional language 
        <a href="http://www.latrobe.edu.au/humanities/research/research-projects/past-projects/joy-programming-language">
          Joy.</a>
        Written in Haskell.
      </p>

      <h3> Haskell algorithms </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/Haskellrithms">
            April 2015.</a>
        </span>
        Implementations of a heap based priority queue,
        red-black trees, prefix trie, suffix trie, find-union of sets,
        and finding minimal spanning trees.
      </p>

      <h3> ForceBoard </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/ForceBoard">
            2013.</a>
        </span>
        A Java application for simulating the motion of objects 
        influenced by gravity, springs, drag, etc.
      </p>

      <h3> Simple Deriver </h3>
      <p>
        <span class="date">
          <a href="https://github.com/ClathomasPrime/DiffEqGrapherTwo">
            2012.</a>
        </span>
        A Java application that parses equations,
        symbolically derives them, and plots the result.
      </p>

      <h2> <span> Other Things </span> </h2>

      <p>
        <a href="https://github.com/elliottwilliams/wheremeet">Here's</a>
        a hackathon project I worked on to help you meet your friends at
        different Purdue dining courts.
      </p>
      <p>
        <a href="misc/probs/fractionFunction.pdf">Here's</a>
        a Purdue problem of the week from back in the day.
        <a href="misc/probs/fractionFunctionPlot.pdf">Here</a>
        is a partial graph of the function constructed,
        where I enumerated rationals in some simple order
        and plotted the value of the function there.
        Seems like the graph is dense in the plane,
        but I don't think I even knew what "dense"
        meant at the time.
      </p>
      <p>
        <a href="misc/torusGraph.png">Here's</a>
        an image I made to explain how to
        derive an equation of the form <code>z = f(x,y)</code>
        for the graph of a Torus.
      </p>
      <p>
        <a href="misc/passwordProblem.pdf">Here's</a>
        a little writeup of a counting problem that
        I found tough and interesting at the time.
      </p>
      <p>
        <a href="misc/perfectRoll.pdf">Here's</a>
        a writeup I did when I took physics about the fact that objects always
        roll down slopes with less acceleration than if they were slipping
        down the slope without rolling.
        I also construct shapes with acceleration arbitrarily close to the
        "slipping acceleration".
      </p>

    </div>
  </body>
</html>
